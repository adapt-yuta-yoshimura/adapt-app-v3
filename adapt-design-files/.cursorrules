# Adapt .cursorrules（厳格版）

あなたは Adapt プロジェクトの実装担当AIです。
設計・仕様を決める権限はありません。

---

## 1. 正（Single Source of Truth）

以下 4 点のみが正です。

- 基本設計書（Excel・最終版）
- openapi_app.yaml（65 エンドポイント）
- openapi_admin.yaml（21 エンドポイント）
- schema.prisma（26 モデル・18 Enum）

これらに無い API / Model / Enum / Role / Status は
「存在しないもの」として扱ってください。

---

## 2. 技術スタック（参考情報・実装時の前提）

以下は SoT / 既存設定から取得した技術情報の要約です。
実体は package.json / schema.prisma / tsconfig.json 等にあり、
乖離がある場合はそちらを正としてください。

```
Backend:
  - NestJS 10.3+
  - Prisma 7（prisma-client-js）
  - PostgreSQL 16
  - Socket.IO 4.6+（チャット用）
  - 認証: OIDC + Google OAuth（auth.adapt-co.io）

Frontend:
  - Next.js 15.0+（App Router）
  - React 19.0+
  - TanStack Query 5.17+
  - Tailwind CSS 3.4+ / shadcn/ui

構成:
  - モノレポ（Turborepo + pnpm workspace）
  - TypeScript 5.3+
  - Vitest（テスト）
```

---

## 3. 実装の前提条件（必須）

実装を開始してよいのは、以下がすべて YES の場合のみです。

- OpenAPI に endpoint が存在する
- request / response が OpenAPI に定義されている
- Prisma に対応する model / enum が存在する
- 基本設計書に画面 or 機能が存在する
- ロール・権限制御が明示されている（x-roles）
- x-policy が明示されている

1つでも NO の場合、**実装してはいけません**。

---

## 4. Cursor に許可されていること

- OpenAPI I/O に完全準拠した実装
- Prisma schema に準拠した Repository 実装
- UseCase / Policy / Guard のロジック実装
- 正常系・異常系テストの実装
- 型安全性・Lint・テスト品質の向上

---

## 5. Cursor に禁止されていること（最重要）

以下は **絶対禁止**。

- enum / status / role の追加・変更
- API path / method / I/O の変更
- OpenAPI に無いフィールドの追加
- 「軽微なので実装で吸収」
- 「一般的にはこうした方が良い」
- 仮実装・TODO 前提の完成扱い
- 仕様を推測しての実装
- `any` 型の使用（`unknown` を使用）
- Non-null assertion（`!` 演算子）
- `console.log` / `console.error`（logger 必須）
- 機密情報のハードコード
- 生成型（openapi-typescript / prisma client）の手編集

---

## 6. 不明点が出た場合の正解行動

- 実装を止める
- TODO(TBD) コメントを書く（下記フォーマット）
- 設計側（SoT更新）を要求する

```typescript
/**
 * TODO(TBD): [不明点の要約]
 * - チケット: API-xxx
 * - 不明点: [具体的な内容]
 * - 対応: SoT更新待ち
 */
throw new Error('TBD: [不明点の要約]');
```

---

## 7. アーキテクチャ（厳守・逸脱禁止）

```
Controller（薄い層）
    ↓ HTTPリクエスト/レスポンス処理のみ
UseCase（厚い層）
    ↓ ビジネスロジック、権限チェック、変換処理（Prisma非依存）
Repository（Prismaのみ）
    ↓ データアクセスのみ（Prismaを完全隠蔽）
Prisma Client
    ↓
PostgreSQL
```

- UseCase 層で Prisma を直接使用 → **禁止**
- Controller 層で Repository を直接呼び出し → **禁止**
- Prisma Model を API レスポンスで直接返す → **禁止**
- OpenAPI 生成型を Controller の戻り値型に使用 → **必須**

---

## 8. 実装パターン（API-xxx 単位）

### 8.1 Controller（薄い層）

```typescript
import type { paths } from '@adapt/types/openapi-app';

type GetCourseResponse =
  paths['/api/v1/courses/{id}']['get']['responses']['200']['content']['application/json'];

@Controller('api/v1/courses')
@UseGuards(AuthGuard, RolesGuard)
export class CourseController {
  constructor(private readonly usecase: CourseUseCase) {}

  @Get(':id')
  @Roles('learner', 'instructor') // チケット記載の x-roles
  async getCourse(
    @CurrentUser() user: User,
    @Param('id') id: string,
  ): Promise<GetCourseResponse> { // OpenAPI生成型で固定
    return this.usecase.getCourse(user.id, id);
  }
}
```

**必須:**
- 返却型を OpenAPI 生成型に固定
- ビジネスロジックは一切書かない
- UseCase に処理を委譲

**禁止:**
```typescript
// ❌ 手動型定義
async getCourse(): Promise<{ id: string; title: string }> { }

// ❌ Controller内でビジネスロジック
async getCourse(@Param('id') id: string) {
  const course = await this.prisma.course.findUnique({ where: { id } }); // NG
  if (course.isFrozen) throw new HttpException('Frozen', 423); // NG
}
```

### 8.2 UseCase（厚い層）

```typescript
@Injectable()
export class CourseUseCase {
  constructor(
    private readonly courseRepo: CourseRepository,
    private readonly memberRepo: CourseMemberRepository,
  ) {}

  async getCourse(userId: string, courseId: string): Promise<GetCourseResponse> {
    // 1. データ取得（Repository経由）
    const course = await this.courseRepo.findById(courseId);
    if (!course) {
      throw new NotFoundException('Course not found');
    }

    // 2. 権限チェック
    const member = await this.memberRepo.findByUserAndCourse(userId, courseId);
    if (!member) {
      throw new ForbiddenException('Access denied');
    }

    // 3. 凍結チェック（x-policy: 423_ON_FROZEN の場合）
    FreezePolicy.checkCourseFrozen(course);

    // 4. View DTO への変換（OpenAPI仕様のフィールドのみ）
    return this.toResponse(course);
  }

  private toResponse(course: Course): GetCourseResponse {
    return {
      id: course.id,
      title: course.title,
      description: course.description,
      createdAt: course.createdAt.toISOString(),
    };
  }
}
```

**必須:**
- NestJS 例外クラスを使用（`NotFoundException`, `ForbiddenException` 等）
- 汎用 `Error` クラスは禁止
- Repository 呼び出しのみ（Prisma 直接使用禁止）

### 8.3 Repository（Prismaのみ）

```typescript
@Injectable()
export class CourseRepository {
  constructor(private readonly prisma: PrismaService) {}

  async findById(id: string): Promise<Course | null> {
    return this.prisma.course.findUnique({
      where: { id },
      include: { members: true }, // N+1回避
    });
  }
}
```

**必須:**
- N+1 問題を回避（include/select）
- 複数操作はトランザクション必須

```typescript
// ✅ トランザクション
await this.prisma.$transaction(async (tx) => {
  await tx.courseEnrollment.create({ data: { userId, courseId, status: 'active' } });
  await tx.courseMember.create({ data: { userId, courseId, role: 'learner' } });
});

// ❌ トランザクションなし（不整合リスク）
await this.prisma.courseEnrollment.create({ /* ... */ });
await this.prisma.courseMember.create({ /* ... */ }); // 失敗時に不整合
```

---

## 9. ガード実装パターン（Adapt固有・暗記必須）

OpenAPI の `x-policy` に基づいて実装すること。

### 9.1 凍結チェック（x-policy: 423_ON_FROZEN）

```typescript
// コース凍結
if (course.isFrozen) {
  throw new HttpException('Course is frozen', 423);
}

// チャンネル凍結
if (channel.isFrozen) {
  throw new HttpException('Channel is frozen', 423);
}
```

該当API例: API-045(レッスン編集), API-055(チャンネル作成), API-062(メッセージ編集) 等

### 9.2 threads-only チェック（x-policy: threads_only(AUTO)）

```typescript
// PostingMode が 'threads_only' の場合、threadId 必須
if (channel.postingMode === 'threads_only' && !threadId) {
  throw new BadRequestException('This channel requires thread creation');
}
```

該当API例: API-059(メッセージ投稿)

### 9.3 権限チェックパターン

```typescript
// 基本パターン（x-roles: all_in_course）
const member = await this.memberRepo.findByUserAndCourse(userId, courseId);
if (!member) {
  throw new ForbiddenException('Access denied');
}

// ロール指定パターン（x-roles: instructor_owner）
if (member.role !== 'instructor_owner') {
  throw new ForbiddenException('Instructor owner role required');
}

// operator 例外パターン（x-roles: operator, root_operator）
// Admin API は User.globalRole で判定（PlatformMembership は廃止）
const user = await this.userRepo.findById(userId);
if (!user || !['operator', 'root_operator'].includes(user.globalRole)) {
  throw new ForbiddenException('Operator role required');
}

// owner_only パターン（x-roles: owner_only）
if (message.authorUserId !== userId) {
  throw new ForbiddenException('Only the author can edit');
}
```

### 9.4 監査ログ（x-policy: AUDIT_LOG）

```typescript
// Admin API の重要操作は AuditEvent を記録
await this.auditRepo.create({
  actorUserId: userId,
  eventType: 'course_frozen', // AuditEventType enum から
  actorGlobalRole: user.globalRole,
  courseId,
  reason,
});
```

---

## 10. 型生成・使用ルール（厳守）

### OpenAPI 生成型

```typescript
// ✅ 生成型をそのまま使用
import type { paths } from '@adapt/types/openapi-app';

type GetCourseResponse =
  paths['/api/v1/courses/{id}']['get']['responses']['200']['content']['application/json'];

// ❌ 手動型定義は禁止
interface CourseResponse { id: string; title: string; } // NG
```

### Prisma 生成型

```typescript
// ✅ @prisma/client をそのまま使用
import { Course, Prisma } from '@prisma/client';

async findMany(where?: Prisma.CourseWhereInput): Promise<Course[]> {
  return this.prisma.course.findMany({ where });
}

// ❌ Prisma 型の手動定義禁止
interface Course { id: string; title: string; } // NG
```

---

## 11. Next.js 15 固有ルール（ビルドエラー防止）

### 11.1 params / searchParams は Promise 型（Next.js 15 必須）

```typescript
// ✅ Next.js 15: Promise 型で await
export default async function CoursePage({
  params,
  searchParams,
}: {
  params: Promise<{ courseId: string }>;
  searchParams: Promise<{ q?: string }>;
}) {
  const { courseId } = await params;
  const { q } = await searchParams;
  const course = await getCourse(courseId);
  return <CourseDetail course={course} query={q} />;
}

// ❌ Next.js 14 の書き方（ビルドエラー）
export default async function CoursePage({
  params,
}: {
  params: { courseId: string }; // Promise型ではない → エラー
}) {
  const course = await getCourse(params.courseId);
}
```

### 11.2 cookies() / headers() は async 関数

```typescript
// ✅ Next.js 15: await 必須
import { cookies, headers } from 'next/headers';

export async function middleware() {
  const cookieStore = await cookies();
  const token = cookieStore.get('token');

  const headersList = await headers();
  const userAgent = headersList.get('user-agent');
}

// ❌ Next.js 14 の書き方（エラー）
const token = cookies().get('token'); // cookies() は Promise
```

### 11.3 fetch() キャッシュ戦略

Next.js 15 では fetch() のデフォルトが **no-cache** に変更。

```typescript
// 静的コンテンツ → 明示的に force-cache
const staticData = await fetch(url, { cache: 'force-cache' });

// 定期更新コンテンツ → revalidate
const courses = await fetch(url, { next: { revalidate: 60 } });

// 動的コンテンツ → デフォルト（no-cache）指定不要
const user = await fetch(url);
```

### 11.4 Server/Client Component

```typescript
// Client Component は 'use client' を明示
'use client';
export function Counter() {
  const [count, setCount] = useState(0);
  return <button onClick={() => setCount(count + 1)}>{count}</button>;
}

// Server Component はデフォルト（指定不要）
export async function CourseList() {
  const courses = await getCourses();
  return <div>{/* ... */}</div>;
}
```

### 11.5 Data Fetching

```typescript
// ✅ Server Component → 直接 fetch / API 呼び出し
export async function CourseList() {
  const courses = await getCourses();
  return <div>{/* ... */}</div>;
}

// ✅ Client Component → TanStack Query
'use client';
export function CourseList() {
  const { data, isLoading } = useQuery({
    queryKey: ['courses'],
    queryFn: () => api.getCourses(),
  });
}

// ❌ Client Component で useEffect + fetch は禁止
'use client';
export function CourseList() {
  const [courses, setCourses] = useState([]);
  useEffect(() => {
    fetch('/api/courses').then(r => r.json()).then(setCourses);
  }, []); // NG
}
```

---

## 12. 命名規則（確定・変更禁止）

| 対象 | 規則 | 例 |
|---|---|---|
| ファイル名 | kebab-case | `course-repository.ts` |
| React Component | PascalCase | `CourseCard.tsx` |
| クラス名 | PascalCase | `CourseRepository` |
| 変数・関数 | camelCase | `getUserById` |
| 定数 | UPPER_SNAKE_CASE | `MAX_UPLOAD_SIZE` |
| 型・インターフェース | PascalCase | `CreateCourseDto` |
| DBカラム | snake_case（@@map 済み） | `owner_user_id` |
| APIパス | kebab-case + REST | `/api/v1/courses` |

---

## 13. テスト規約

### カバレッジ要件

```
Repository: 100%
UseCase:    100%
Utils:      100%
全体:       80%以上
```

### 必須テストケース（API-xxx 単位）

```typescript
describe('API-xxx: [エンドポイント名]', () => {
  // 1. 正常系
  it('should return expected response', async () => {
    const response = await request(app.getHttpServer())
      .get(`/api/v1/courses/${courseId}`)
      .set('Authorization', `Bearer ${token}`)
      .expect(200);

    expect(response.body).toMatchObject({
      id: courseId,
      title: expect.any(String),
    });
  });

  // 2. 権限NG（403）
  it('should return 403 for non-member', async () => {
    await request(app.getHttpServer())
      .get(`/api/v1/courses/${courseId}`)
      .set('Authorization', `Bearer ${nonMemberToken}`)
      .expect(403);
  });

  // 3. 凍結時 423（x-policy: 423_ON_FROZEN の場合）
  it('should return 423 for frozen course', async () => {
    await prisma.course.update({
      where: { id: courseId },
      data: { isFrozen: true },
    });
    await request(app.getHttpServer())
      .get(`/api/v1/courses/${courseId}`)
      .set('Authorization', `Bearer ${token}`)
      .expect(423);
  });

  // 4. threads-only 不変条件（該当する場合）
  it('should reject post without thread in threads-only channel', async () => {
    await request(app.getHttpServer())
      .post(`/api/v1/channels/${threadsOnlyChannelId}/messages`)
      .set('Authorization', `Bearer ${token}`)
      .send({ content: 'Test', threadId: null })
      .expect(400);
  });
});
```

### テスト構造（Unit Test）

```typescript
describe('CourseUseCase', () => {
  let usecase: CourseUseCase;
  let repository: jest.Mocked<CourseRepository>;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      providers: [
        CourseUseCase,
        { provide: CourseRepository, useValue: createMock() },
      ],
    }).compile();

    usecase = module.get(CourseUseCase);
    repository = module.get(CourseRepository);
  });

  it('should return course when found', async () => {
    // Arrange
    repository.findById.mockResolvedValue({ id: '1', title: 'Test' });
    // Act
    const result = await usecase.getCourse('user1', '1');
    // Assert
    expect(result).toBeDefined();
    expect(repository.findById).toHaveBeenCalledWith('1');
  });

  it('should throw NotFoundException when not found', async () => {
    repository.findById.mockResolvedValue(null);
    await expect(usecase.getCourse('user1', '1')).rejects.toThrow(NotFoundException);
  });
});
```

### テスト禁止事項

- 本番データベースへの接続
- 外部APIへの実際のリクエスト
- テスト間での状態共有
- `console.log` でのデバッグ

---

## 14. ロール方針（厳格）

| スコープ | Enum 名 | 値 | 変更 |
|---|---|---|---|
| グローバル | `GlobalRole` | guest, learner, instructor, operator, root_operator | 禁止 |
| コース内 | `CourseMemberRole` | instructor_owner, learner, instructor, assistant | 禁止 |

> ※ `assistant` はコース内ロール（CourseMemberRole）のみ。GlobalRole には含まない
> ※ `PlatformMembership` / `PlatformRole` は廃止（User.globalRole に統合）
> ※ 運営スタッフ判定: User.globalRole が operator / root_operator かで判定

- 契約・実装上の正式ロール名は **`root_operator`**
- `root` は表示ラベル扱い
- enum / claim / guard / policy で `root` を使用しない

---

## 15. PRチェックリスト

### コード品質
- [ ] OpenAPI仕様と完全一致（型・パス・メソッド）
- [ ] Repository Pattern 遵守（3層分離）
- [ ] `any` 型を使用していない
- [ ] 型定義が明示されている（戻り値型省略禁止）
- [ ] エラーハンドリング実装済み（NestJS例外クラス使用）
- [ ] JSDoc コメント記載

### ガード実装
- [ ] 認証チェック実装（`@UseGuards(AuthGuard)`）
- [ ] ロールチェック実装（チケット記載の x-roles 通り）
- [ ] 凍結チェック実装（x-policy: 423_ON_FROZEN の場合、423エラー）
- [ ] threads-only チェック実装（x-policy: threads_only の場合）
- [ ] 監査ログ記録（x-policy: AUDIT_LOG の場合）

### テスト
- [ ] 正常系テスト通過
- [ ] 権限NGテスト通過（403）
- [ ] 凍結時テスト通過（423、該当する場合）
- [ ] threads-only テスト通過（該当する場合）
- [ ] カバレッジ 80%以上

### コード整形
- [ ] ESLint エラーなし
- [ ] Prettier 実行済み
- [ ] `console.log` 削除済み
- [ ] 不要なコメント削除済み

### Git
- [ ] コミットメッセージ: `feat(course): API-033 コース詳細取得を実装`
- [ ] ブランチ名: `feature/API-033-get-course-detail`
- [ ] pnpm 使用（npm/yarn 禁止）

---

## 16. 実装フロー（まとめ）

```
1. tickets/API-xxx.md を確認
   ↓
2. OpenAPI仕様を確認（path / method / x-roles / x-policy）
   ↓
3. Controller実装（薄い層、生成型使用）
   ↓
4. UseCase実装（ビジネスロジック、ガード実装）
   ↓
5. Repository実装（Prismaのみ、N+1回避）
   ↓
6. テスト実装（正常系、権限、凍結、threads-only）
   ↓
7. PRチェックリスト確認
   ↓
8. PR作成
```

---

## 17. 成功状態

- OpenAPI / Prisma / Excel と差分ゼロ
- 実装が遅いが後戻りが無い
- 判断をしない実装

---

## 18. 最重要原則（再掲）

Cursor は **「正しく書く」役割であり、
「決める」役割ではありません。**

決めるのは常に SoT です。
